<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>临水轩志 on 临水轩志</title>
    <link>https://yumminhuang.github.io/</link>
    <description>Recent content in 临水轩志 on 临水轩志</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>2017 ~ Yaming Huang</copyright>
    <lastBuildDate>Sun, 10 Sep 2017 11:31:51 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
      
        
          <item>
            <title>搭建分布式 Gerrit 集群</title>
            <link>https://yumminhuang.github.io/post/distributedgerrit/</link>
            <pubDate>Sun, 10 Sep 2017 11:31:51 +0800</pubDate>
            
            <guid>https://yumminhuang.github.io/post/distributedgerrit/</guid>
            <description>&lt;p&gt;&lt;a href=&#34;https://www.gerritcodereview.com&#34;&gt;Gerrit&lt;/a&gt; 是由 Google为了管理 Android 项目而开发的，一款免费、开源的代码审查软件。Gerrit 使用 Git 作为底层版本控制系统，提供了代码审查、权限管理等功能。&lt;/p&gt;

&lt;p&gt;本文将会简单介绍如何搭建分布式 Gerrit 集群，即搭建由一个可以读写的 Gerrit Master 和若干个只读的 Gerrit Slave 组成的 Gerrit 集群。Gerrit Slave 可以实时同步 Gerrit Master 的数据，保证代码的一致性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;分布式的架构可以用来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;分流下载：下载代码可以从只读的 Slave 下载，从而减轻 Master 的负载。如果 Slave 和 Master 在不同地区，还可以起到加速下载的功效。&lt;/li&gt;
&lt;li&gt;灾备切换：如果 Master 出现故障，可以切换到 Slave 继续工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分布式-gerrit-架构&#34;&gt;分布式 Gerrit 架构&lt;/h2&gt;

&lt;p&gt;Gerrit 里的数据主要是两部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Git 代码库，用来存储代码；&lt;/li&gt;
&lt;li&gt;数据库&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:database&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:database&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，用来存储代码提交（Change），用户、分组权限等信息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此在实现分布式 Gerrit 时，对应两部分数据，我们需要通过：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org&#34;&gt;PostgreSQL&lt;/a&gt; &lt;a href=&#34;https://wiki.postgresql.org/wiki/Streaming_Replication&#34;&gt;Streaming Replication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gerrit.googlesource.com/plugins/replication&#34;&gt;&lt;em&gt;Gerrit Replication&lt;/em&gt; 插件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来实现 Gerrit Master 和 Gerrit Slave 之间的数据同步。&lt;/p&gt;

&lt;p&gt;分布式 Gerrit 架构如下图所示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----------------------+                  +--------------------+
|                      |                  |                    |
|    Gerrit Master     |                  |    Gerrit Slave    |
|       Server         |                  |       Server       |
|                +-----+-----+            |                    |
|   +----------+ |  Gerrit   |            |     +----------+   |
|   |Repository| |Replication|  git push  |     |Repository|   |
|   |          +-+  Plugin   +-----------------&amp;gt;+          |   |
|   +----------+ +-----+-----+            |     +----------+   |
|                      |                  |                    |
|   +--------------+   |                  |  +--------------+  |
|   |   PostgreSQL |   |  Replication     |  | PostgreSQL   |  |
|   |    PRIMARY   +------------------------&amp;gt;+ HOT-STANDBY  |  |
|   +--------------+   |                  |  +--------------+  |
+----------------------+                  +--------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Gerrit Master 和 Slave 上都有一个相同的 Git 代码库（*Repository*），Gerrit Replication 插件可以用来将 Master 上收到的更新（新提交的 commit，&lt;code&gt;refs/meta&lt;/code&gt; 分支下的变更或是创建的新代码库）同步到 Slave。&lt;/p&gt;

&lt;p&gt;为了实现数据库的同步，需要将 PostgreSQL 运行在 &lt;a href=&#34;https://www.postgresql.org/docs/9.4/static/hot-standby.html&#34;&gt;Hot Standby 模式&lt;/a&gt;。 在 Gerrit Master 上运行的 PostgreSQL 是 &lt;em&gt;primary&lt;/em&gt; ，可以进行读、写操作； 在 Gerrit Slave 上运行的 PostgreSQL 是 &lt;em&gt;stanby&lt;/em&gt; ，可以和 &lt;em&gt;primary&lt;/em&gt; 保持同步，可以接受客户端的连接，但只能进行读操作。如果 &lt;em&gt;primary&lt;/em&gt; 故障了，整个系统可以迁移（ &lt;em&gt;fail over&lt;/em&gt; ）到 &lt;em&gt;stanby&lt;/em&gt; ，由 &lt;em&gt;stanby&lt;/em&gt; 承担 &lt;em&gt;primary&lt;/em&gt; 的角色。&lt;/p&gt;

&lt;h2 id=&#34;分布式-gerrit-配置&#34;&gt;分布式 Gerrit 配置&lt;/h2&gt;

&lt;h3 id=&#34;配置-gerrit&#34;&gt;配置 Gerrit&lt;/h3&gt;

&lt;p&gt;对于安装和配置 Gerrit Master，分布式的搭建和单点的搭建并没有区别。&lt;/p&gt;

&lt;h4 id=&#34;gerrit-slave&#34;&gt;Gerrit Slave&lt;/h4&gt;

&lt;p&gt;安装和配置 Gerrit Slave 上的 Gerrit 的时候，需要注意在 &lt;code&gt;gerrit.config&lt;/code&gt; 文件里的 &lt;code&gt;[container]&lt;/code&gt; 下面添加 &lt;code&gt;slave = true&lt;/code&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[container]
    user = gerrit2
    javaHome = /usr/lib/jvm/java-7-oracle/jre
    javaOptions = -Xmx80g -Xms20g -Xmn2g
    slave = true
[database]
    type = postgresql
    database = reviewdb
    hostname = localhost
    username = gerrit2
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样 Gerrit 才会启动为 Slave。&lt;/p&gt;

&lt;h3 id=&#34;配置-postgresql-数据库&#34;&gt;配置 PostgreSQL 数据库&lt;/h3&gt;

&lt;p&gt;在 Master 上要配置 &lt;code&gt;/etc/postgresql/9.4/main/postgresql.conf&lt;/code&gt;，打开 Hot Standby 功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
wal_level = hot_standby
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要在 &lt;code&gt;/etc/postgresql/9.4/main/pg_hba.conf&lt;/code&gt; 添加  &lt;em&gt;stanby&lt;/em&gt; 的 IP，确保 &lt;em&gt;stanby&lt;/em&gt; 可以连接  &lt;em&gt;primary&lt;/em&gt; 进行同步。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host   replication   all    POSTGRES.STANDBY.IP.ADDRESS/32       md5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Slave 上首先需要配置 &lt;code&gt;/etc/postgresql/9.4/main/postgresql.conf&lt;/code&gt;，设置 PostgreSQL 运行为 &lt;em&gt;stanby&lt;/em&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
hot_standby = on
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，添加 &lt;code&gt;/var/lib/postgresql/9.4/main/recovery.conf&lt;/code&gt; 文件，配置  &lt;em&gt;primary&lt;/em&gt;  信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;standby_mode = on 
primary_conninfo = &#39;host=POSTGRES.PRIMAY.IP.ADDRESS port=5432 user=replicator password=PASSWORD&#39;
trigger_file = &#39;/var/lib/postgresql/postgresql.trigger&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;trigger_file&lt;/code&gt; 被用来触发 &lt;em&gt;fail over&lt;/em&gt; ，此时不需要创建。&lt;/p&gt;

&lt;p&gt;配置完成后，在 &lt;em&gt;primary&lt;/em&gt;  上运行命令将数据拷贝到 &lt;em&gt;standby&lt;/em&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rsync -av --exclude pg_xlog --exclude postgresql.conf data/* \
	POSTGRES.STANDBY.IP.ADDRESS:/var/lib/postgresql/data/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启两端的 PostgreSQL 后，&lt;em&gt;primary&lt;/em&gt; 和 &lt;em&gt;standby&lt;/em&gt; 将保持同步。&lt;/p&gt;

&lt;p&gt;关于 Hot Standby 的详细的说明，可以参见 Postgresql 的这篇&lt;a href=&#34;https://wiki.postgresql.org/wiki/Hot_Standby&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;配置-gerrit-replication&#34;&gt;配置 Gerrit Replication&lt;/h3&gt;

&lt;h4 id=&#34;gerrit-slave-1&#34;&gt;Gerrit Slave&lt;/h4&gt;

&lt;p&gt;首先需要在 Gerrit Slave 上配置 xinetd，用来提供 git daemon 服务。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt install xinetd
$ cat /etc/xinetd.d/git-daemon
 
# default: off
# description: The git server offers access to git repositories service git
service git
{
        disable = no
        type = UNLISTED
        port = 9418
        socket_type = stream
        wait = no
        env  = HOME=/home/gerrit2
        user = gerrit2
        server = /usr/bin/git
        only_from = gerrit-master.example.com
        log_type = SYSLOG daemon info
        server_args = daemon --inetd --syslog --export-all --enable=upload-pack --enable=receive-pack --base-path=/home/gerrit2/review_site/git --verbose
        log_on_success += USERID HOST DURATION EXIT
        log_on_failure += USERID HOST ATTEMPT
        cps = 150 10
}
$ sudo /etc/init.d/xinetd restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启 xinetd 之后，9418 端口将会开启，可以通过 &lt;code&gt;git://&lt;/code&gt; 访问 Gerrit Slave 上的代码库。&lt;/p&gt;

&lt;h4 id=&#34;gerrit-master&#34;&gt;Gerrit Master&lt;/h4&gt;

&lt;p&gt;在 Gerrit Master 上，首先需要安装 Gerrit Replication 插件，下载对应 Gerrit 版本的 Replication 插件 jar 文件，并添加到 &lt;code&gt;$REVIEW_SITE/plugin&lt;/code&gt; 目录下。&lt;/p&gt;

&lt;p&gt;接下来，添加 &lt;code&gt;$REVIEW_SITE/etc/replication.config&lt;/code&gt; 文件，加上 Gerrit Slave 的配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[remote &amp;quot;slave&amp;quot;]
  url = git://gerrit-slave.example.com/${name}.git 
  mirror = true
  threads = 4
  adminUrl = ssh://gerrit-slave.example.com/home/gerrit2/review_site/git/${name}.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，&lt;code&gt;adminUrl&lt;/code&gt; 的路径要按照 Gerrit Slave 上代码库真实的存放路径设置。&lt;/p&gt;

&lt;p&gt;这样，启动 Gerrit Master 之后，每次代码库有变更，Gerrit Replication 插件都会将变更通过 git 协议 Push 到 Slave 上。&lt;/p&gt;

&lt;p&gt;通常，在启动 Gerrit Slave 之前，需要将代码库拷贝到 Slave 机器上，以缩短首次同步的时间。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;分布式 Gerrit 搭建完成之后，我们可以添加 &lt;code&gt;.gitconfig&lt;/code&gt; 文件来实现代码上传和下载分流。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[url &amp;quot;ssh://&amp;lt;username&amp;gt;@gerrit-slave.example.com:29418&amp;quot;]
    insteadOf = gerrit
    pushInsteadOf = ssh://&amp;lt;username&amp;gt;@gerrit-master.example.com:29418
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，克隆代码库的时候使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone gerrit:path/to/repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以从 Gerrit Slave 下载代码，而 &lt;code&gt;git push&lt;/code&gt; 的时候会自动将代码 Push 到 Gerrit Master。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/community/tutorials/setting-up-postgres-hot-standby#understanding-hot-standby&#34;&gt;Setting Up Postgres Hot Standby&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:database&#34;&gt;Gerrit 支持大部分主流的关系型数据库，具体的配置方法可以参见&lt;a href=&#34;https://gerrit-review.googlesource.com/Documentation/database-setup.html&#34;&gt;建立数据库&lt;/a&gt; 和&lt;a href=&#34;https://gerrit-review.googlesource.com/Documentation/config-gerrit.html#database&#34;&gt;配置数据库&lt;/a&gt;的官方文档。本文以 PostgreSQL 为例。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:database&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
          </item>
        
      
    
      
        <item>
          <title>Linklog: 为什么我不用微信</title>
          <link>https://yumminhuang.github.io/link/whynotwechat/</link>
          <pubDate>Thu, 06 Jul 2017 20:48:02 +0800</pubDate>
          <author>Kyle</author>
          <guid>https://yumminhuang.github.io/link/whynotwechat/</guid>
          <description>&lt;p&gt;我目前在生活中还不能完全摆脱微信，虽然我仍然在不断地努力尝试中。除了「为什么我不用微信」里提到的诸多原因之外，每当：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一些同事在微信发来一长串&lt;strong&gt;凌乱的&lt;/strong&gt;代码片段或者文件的时候；&lt;/li&gt;
&lt;li&gt;刚见面的陌生人提出加微信的时候；&lt;/li&gt;
&lt;li&gt;想到在微信里的聊天内容处在政府的监控之中的时候。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;都让我坚定了离开微信的决心。&lt;/p&gt;
</description>
        </item>
      
    
      
    
      
    
      
    
      
        
          <item>
            <title>自动构建 Github Pages 博客</title>
            <link>https://yumminhuang.github.io/post/autobuildblog/</link>
            <pubDate>Sat, 12 Nov 2016 12:31:51 +0800</pubDate>
            
            <guid>https://yumminhuang.github.io/post/autobuildblog/</guid>
            <description>&lt;p&gt;之前曾经写过了一篇 &lt;a href=&#34;https://yumminhuang.github.io/post/AutoBuildResume/&#34;&gt;使用 Travis CI 和 Docker 自动构建 LaTeX 简历&lt;/a&gt;，介绍了使用 Travis CI 和 Docker 自动构建和发布 LaTeX 简历的方法。&lt;/p&gt;

&lt;p&gt;以前每次写了新文章之后，都需要在笔记本上运行一下 Hugo 再将生成的网页上传到 Github。虽然使用脚本也可以做到一键发布，但总觉得不够流畅。昨天，我又使用了同样的方法，将基于 Github Pages 的博客也实现了自动构建和发布。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;整理工作&#34;&gt;整理工作&lt;/h3&gt;

&lt;p&gt;之前，为了搭建 &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt; 的博客，我创建了两个代码库。一个是存放网站的 yumminhuang.github.io.git，另外一个是存放 Hugo 配置和文章的 Blog.git。每次发布一篇文章，都需要同步两个代码库。&lt;/p&gt;

&lt;p&gt;两个代码库也没有必要。于是我把 Blog.git 库删除了，把 Hugo 的配置和文章都存放在了 yumminhuang.github.io.git 的 source 分支里。&lt;/p&gt;

&lt;p&gt;当然，还是有必要保留以前提交的历史记录。大概的操作流程是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;git clone git@github.com/yumminhuang/Blog.git
cd Blog
# Delete the old remote
git remote rm origin
# Add a new remote
git remote add origin git@github.com:yumminhuang/yumminhuang.github.io.git
# (Optional) Modify .git/config for submodules, etc
vi .git/config
# Create the new branch and switch to it
git checkout -b source
# Push the new branch to remote
git push origin source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，原来 Blog.git 里的内容和提交历史就保存到了 yumminhuang.github.io.git 的 source 分支里。&lt;/p&gt;

&lt;h3 id=&#34;docker-for-hugo&#34;&gt;Docker for Hugo&lt;/h3&gt;

&lt;p&gt;接下来的任务就是创建一个 Docker 容器来生成网页。参考了一些网上的 Hugo Dockerfile 之后，我写了如下的一个 &lt;a href=&#34;https://github.com/yumminhuang/hugo-docker&#34;&gt;Dockerfile&lt;/a&gt; 用来生成 Docker Image。 这个 Image 只安装了 Hugo，比较小巧，压缩后只有 8MB，很适合用来在 CI 系统上使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM alpine:latest
MAINTAINER Yaming Huang &amp;lt;yumminhuang@gmail.com&amp;gt;

ARG HUGO_VERSION=0.17

RUN apk add --update wget ca-certificates &amp;amp;&amp;amp; \
  cd /tmp/ &amp;amp;&amp;amp; \
  wget https://github.com/spf13/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.tar.gz &amp;amp;&amp;amp; \
  tar xzf hugo_${HUGO_VERSION}_Linux-64bit.tar.gz &amp;amp;&amp;amp; \
  rm -r hugo_${HUGO_VERSION}_Linux-64bit.tar.gz &amp;amp;&amp;amp; \
  mv hugo*/hugo* /usr/bin/hugo &amp;amp;&amp;amp; \
  apk del wget ca-certificates &amp;amp;&amp;amp; \
  rm /var/cache/apk/*

VOLUME /website
VOLUME /public

WORKDIR /website
ENTRYPOINT [&amp;quot;/usr/bin/hugo&amp;quot;]

EXPOSE 1313
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Build 之后生成 &lt;code&gt;yumminhuang/hugo-docker&lt;/code&gt;， 这样每次运行一条命令，就可以生成网页到 &lt;code&gt;public&lt;/code&gt; 目录下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -v $(pwd):/website yumminhuang/hugo:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以运行如下的命令用来看网页生成的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -p 1313:1313 -v $(pwd):/website yumminhuang/hugo:latest server --bind=0.0.0.0 -w -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;travis-ci&#34;&gt;Travis CI&lt;/h3&gt;

&lt;p&gt;接下来是设置 Travis CI 来进行自动构建。&lt;/p&gt;

&lt;p&gt;首先，需要先到 Github 的&lt;a href=&#34;https://github.com/settings/tokens&#34;&gt;个人设置&lt;/a&gt;页面去&lt;a href=&#34;https://help.github.com/articles/creating-an-access-token-for-command-line-use/&#34;&gt;创建一个 “Personal Access Token”&lt;/a&gt;。确保选择了 &lt;code&gt;repo&lt;/code&gt; 下面的 &lt;code&gt;public_repo&lt;/code&gt;。 创建出来的 “Personal Access Token” 可以用来读、写代码库，所以要妥善保管，不能外泄。&lt;/p&gt;

&lt;p&gt;接着，需要使用 &lt;a href=&#34;https://github.com/travis-ci/travis.rb&#34;&gt;Travis 命令行工具&lt;/a&gt;来对包含新生成 “Personal Access Token”  的变量 &lt;code&gt;GIT_DEPLOY_REPO&lt;/code&gt; 加密。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;travis encrypt GIT_DEPLOY_REPO=https://GENERATED_TOKEN@github.com/username/reponame.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GIT_DEPLOY_REPO&lt;/code&gt; 将用于把网页上传到 Github，后文会有提及。&lt;/p&gt;

&lt;p&gt;完整的 &lt;code&gt;.travis.yml&lt;/code&gt; 如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;env:
  global:
  - secure: &amp;quot; LONG TOKEN &amp;quot;
  - GIT_DEPLOY_DIR=public
  - GIT_DEPLOY_BRANCH=master
  - GIT_DEPLOY_USERNAME=&amp;quot;Travis CI&amp;quot;
  - GIT_DEPLOY_EMAIL=yumminhuang@gmail.com

branches:
  only:
    - source

sudo: required

services:
  - docker

install:
  - rm -rf public || exit 0
  - git config --global user.email &amp;quot;yumminhuang@gmail.com&amp;quot;
  - git config --global user.name &amp;quot;Travis CI&amp;quot;

script:
  - docker run --rm -v $(pwd):/website yumminhuang/hugo:latest

after_success:
  - wget https://raw.githubusercontent.com/X1011/git-directory-deploy/master/deploy.sh -O deploy.sh
  - bash deploy.sh -m &amp;quot;updating blog `date`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;after_success&lt;/code&gt;，也即 Hugo 完成网页生成之后，会使用 &lt;a href=&#34;https://github.com/X1011/git-directory-deploy&#34;&gt;X1011/git-directory-deploy&lt;/a&gt; 里的 &lt;code&gt;deploy.sh&lt;/code&gt; 将网页提交并上传到 Github。使用 &lt;code&gt;deploy.sh&lt;/code&gt; 只需要设置这几个变量，就可以完成把一个目录同步到 Github 的功能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GIT_DEPLOY_REPO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_DEPLOY_DIR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_DEPLOY_BRANCH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_DEPLOY_USERNAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT_DEPLOY_EMAIL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，在 Travis CI 上完成授权，就能够在每次提交到 &lt;code&gt;source&lt;/code&gt; 分支后出发自动构建了。&lt;/p&gt;

&lt;h3 id=&#34;参考内容&#34;&gt;参考内容&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://speps.github.io/articles/hugo-setup/&#34;&gt;Setup Hugo with Travis CI and GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.hypriot.com/post/static-website-generation-on-steriods-with-docker/&#34;&gt;Static Website Generation on Steriods with Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jojomi/docker-hugo&#34;&gt;jojomi/docker-hugo&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
          </item>
        
      
    
      
        
          <item>
            <title>使用 Travis CI 和 Docker 自动构建 LaTeX 简历</title>
            <link>https://yumminhuang.github.io/post/autobuildresume/</link>
            <pubDate>Fri, 08 Apr 2016 15:17:48 -0400</pubDate>
            
            <guid>https://yumminhuang.github.io/post/autobuildresume/</guid>
            <description>&lt;p&gt;又快到了求职季，最近一段时间总是频繁更新的简历。之前，我的简历更新流程是先修改简历，使用 MacTeX 编译，再把 PDF 版的简历同步到几个网盘备份。过程倒也不算繁琐。但再做过几个月的运维开放之后，我对自动化有着近乎偏执的热情。这几天经过不断的尝试和摸索，在 Travis-CI 上运行了十几个 Build 之后，终于使用 Docker 实现了一个便捷的自动化发布 LaTeX 简历的方法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本文中提到的简历已经放在了 &lt;a href=&#34;https://github.com/yumminhuang/Resume&#34;&gt;GitHub&lt;/a&gt; 上，欢迎参考。&lt;/p&gt;

&lt;p&gt;当然，本文的主要内容集中在持续发布的流程，而非 LaTeX 和 Docker 的使用，所以对 LaTeX 简历和 Docker 命令不做细致的解释。事实上，GitHub 上有很多精美的 LaTeX 简历模板，我的简历也借鉴了其中的一个模板。&lt;/p&gt;

&lt;h3 id=&#34;使用-travis-ci-自动发布&#34;&gt;使用 Travis-CI 自动发布&lt;/h3&gt;

&lt;p&gt;上周在 &lt;a href=&#34;http://www.latexstudio.net&#34;&gt;LaTeX 开源小屋&lt;/a&gt;看到一篇&lt;a href=&#34;http://www.latexstudio.net/archives/5892&#34;&gt;文章&lt;/a&gt;。文章中介绍了 GitHub 上一个&lt;a href=&#34;https://github.com/SivilTaram/BUAAOS-guide-book&#34;&gt;北航小操作系统实验指导书&lt;/a&gt;的代码库。这个代码库里使用 Travis-CI 与 LaTeX 构建开源中文 PDF。每次提交到 GitHub 之后，可以自动运行 Travis-CI 编译，并将 PDF 文件发布到 &lt;a href=&#34;https://help.github.com/articles/about-releases/&#34;&gt;GitHub Release 页面&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;于是，我以此开源项目为模板，同时参考了另一篇文章 &lt;a href=&#34;http://harshjv.github.io/blog/setup-latex-pdf-build-using-travis-ci/&#34;&gt;&lt;em&gt;Setup LaTeX PDF build using Travis CI&lt;/em&gt;&lt;/a&gt; 及&lt;a href=&#34;https://github.com/harshjv/travis-ci-latex-pdf&#34;&gt;代码&lt;/a&gt;，将自己的简历实现了自动化编译与发布。&lt;/p&gt;

&lt;p&gt;先看一下我的 &lt;code&gt;.travis.yml&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo: required
dist: trusty
before_install:
- sudo apt-get update
- sudo apt-get -y --no-install-recommends install texlive-full
- sudo wget -P /usr/share/fonts/opentype/ https://github.com/SivilTaram/BUAAOS-guide-book/raw/master/guide-book/fonts/AdobeFangsongStd-Regular.otf
- sudo wget -P /usr/share/fonts/opentype/ &amp;quot;https://github.com/SivilTaram/BUAAOS-guide-book/raw/master/guide-book/fonts/AdobeHeitiStd-Regular%20(v5.010).otf&amp;quot;
- sudo wget -P /usr/share/fonts/opentype/ &amp;quot;https://github.com/SivilTaram/BUAAOS-guide-book/raw/master/guide-book/fonts/AdobeKaitiStd-Regular%20(v5.010).otf&amp;quot;
- sudo wget -P /usr/share/fonts/opentype/ &amp;quot;https://github.com/SivilTaram/BUAAOS-guide-book/raw/master/guide-book/fonts/AdobeSongStd-Light%20(v5.010).otf&amp;quot;
- sudo mkfontscale
- sudo mkfontdir
- sudo fc-cache -f
script:
- cd resume
- make
- cd ..
- mv resume/Resume.pdf Resume.pdf
- mv resume/Resume_ZH.pdf Resume_ZH.pdf
deploy:
  provider: releases
  api_key:
    secure: [A LONG LONG TOKEN, omit it]
  file:
    - Resume.pdf
    - Resume_ZH.pdf
  skip_cleanup: true
  on:
    repo: yumminhuang/Resume
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先前两行声明了需要的权限和使用 &lt;a href=&#34;https://docs.travis-ci.com/user/trusty-ci-environment/&#34;&gt;Travis CI 的 Trusty（即 Ubuntu 14.04）编译环境&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接着，&lt;code&gt;before_install&lt;/code&gt; 后的命令用来安装 texlive 和字体，更新系统字体列表。&lt;/p&gt;

&lt;p&gt;然后，在 &lt;code&gt;script&lt;/code&gt; 阶段，运行 &lt;code&gt;make&lt;/code&gt; 命令编译，移动 PDF 文件到项目的根目录。&lt;/p&gt;

&lt;p&gt;最后，在 &lt;code&gt;deploy&lt;/code&gt; 阶段，使用 Travis-CI 的 API 将文件发布到 Github Release。这里，需要一个 &lt;code&gt;api_key&lt;/code&gt;，可以运行 &lt;a href=&#34;https://github.com/travis-ci/travis.rb#installation&#34;&gt;Travis 命令行客户端&lt;/a&gt;来生成。关于使用 Travis-CI 将文件发布到 Github Release 的更详细内容还请参考 &lt;a href=&#34;https://docs.travis-ci.com/user/deployment/releases&#34;&gt;Travis-CI 的官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这样，我就完成了可以自动编译、自动发布的 &lt;a href=&#34;https://github.com/yumminhuang/Resume/releases/tag/v1.0&#34;&gt;1.0 版&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;优化持续发布流程&#34;&gt;优化持续发布流程&lt;/h3&gt;

&lt;p&gt;1.0 版完成只实现了自动化，还有一些不令人满意的地方。&lt;/p&gt;

&lt;p&gt;第一，安装过程复杂，构建花费时间长。每次构建大概需要 10 分钟左右，大部分的时间都花在安装 texlive 上。「北航实验指导书」中选择安装 texlive-full，这避免了缺少依赖的问题，但却安装了很多没有用的依赖，同时花费了大量时间。另外，下载字体也花费了一定的时间。&lt;/p&gt;

&lt;p&gt;第二，频繁的不必要的构建。按照「北航实验指导书」中的设置，每次提交一个更新都会触发构建。事实上，这是没有必要的，因为有时候可能只是更新 README，而非 LaTeX 源码。「北航实验指导书」中为了避免这一问题，很多提交更新都加上了 &lt;code&gt;[ci skip]&lt;/code&gt; 的前缀来&lt;a href=&#34;https://docs.travis-ci.com/user/customizing-the-build/#Skipping-a-build&#34;&gt;跳过自动构建&lt;/a&gt;。这样无形中增加了开发过程的负担。&lt;/p&gt;

&lt;p&gt;最后，编译出来的中文简历格式令我不要满意。Ubuntu trusty 的环境中，使用 &lt;code&gt;apt-get&lt;/code&gt; 只能安装 texlive 2013；而我的中文简历使用了新版 ctex 的特性，需要用到 texlive 2015。如果在 trusty 里下载 texlive 2015 的镜像安装可能又需要安装更多的工具链，很麻烦；在 Ubuntu 15.10 和 Ubuntu 16.04 中倒是可以使用 &lt;code&gt;apt-get&lt;/code&gt; 安装 texlive 2015，但 Travis-CI 似乎只提供了 Ubuntu trusty，没有更新的版本。&lt;/p&gt;

&lt;p&gt;为了解决这三个问题，我做了两点改进。&lt;/p&gt;

&lt;h4 id=&#34;使用-docker-编译&#34;&gt;使用 Docker 编译&lt;/h4&gt;

&lt;p&gt;既然 Ubuntu 16.04 可以安装运行 texlive 16.04，何不使用 Docker 容器来运行？同时，为了避免安装没用的软件包，我花了一些时间找出了编译中文 LaTeX 的必要依赖和宏包，然后将安装和编译的过程写成一个脚本 &lt;code&gt;build.sh&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

# install texlive 2015 and dependencies
apt-get update &amp;amp;&amp;amp; \
apt-get install -y --no-install-recommends \
    texlive-latex-extra \
    texlive-latex-recommended \
    texlive-fonts-extra \
    texlive-fonts-recommended \
    texlive-lang-chinese \
    texlive-formats-extra \
    lmodern \
    wget \
    xzdec

# intsall latex packages
tlmgr init-usertree
tlmgr install ulem

cd resume/
# run xelatex
xelatex Resume.tex -interaction=nonstopmode
xelatex Resume_ZH.tex -interaction=nonstopmode

rm *.aux *.log *.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，使用一个 Ubuntu 16.04 的容器运行该脚本就可以生成简历了。接着，我把 &lt;code&gt;.travis.yml&lt;/code&gt; 的 &lt;code&gt;before_install&lt;/code&gt; 和 &lt;code&gt;script&lt;/code&gt; 过程简化成下面的设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;services:
  - docker

script:
- docker run --rm -v $(pwd)/resume:/resume ubuntu:xenial bash /resume/build.sh
- mv resume/Resume.pdf Resume.pdf
- mv resume/Resume_ZH.pdf Resume_ZH.pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要过程就是创建一个 Ubuntu xenial 容器来运行 &lt;code&gt;build.sh&lt;/code&gt;。后面发布过程的设置和 1.0 版一样。&lt;/p&gt;

&lt;p&gt;最后，使用 Docker 之后，不仅可以编译出格式满意的简历，而且我惊喜地发现整个构建过程耗时 3 分钟多，只有之前的 1/3。&lt;/p&gt;

&lt;h4 id=&#34;build-tagged-commits-only&#34;&gt;Build tagged commits only&lt;/h4&gt;

&lt;p&gt;为了避免不必要的构建，我在 &lt;code&gt;.travis.yml&lt;/code&gt; 中加入下面三行内容作为「白名单」，即使用正则表达式规定需要构建的 branches。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;branches:
  only:
    - /^v[\d.]+\d$/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，Travis-CI 把 git 的标签（tag）和分支（branch）都视作 branches，关于如何设置特定 branch 进行构建，可以参见&lt;a href=&#34;https://docs.travis-ci.com/user/customizing-the-build/#Building-Specific-Branches&#34;&gt;Travis-CI 的官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这样，我平时可以正常地提交更新而不会触发 Travis-CI。需要发布新的简历时，按照 &lt;code&gt;^v[\d.]+\d$&lt;/code&gt; 的格式，比如 &lt;code&gt;v1.2.1&lt;/code&gt;，加一个标签再提交即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add -a
git commit -m &amp;quot;Message&amp;quot;
git tag v1.2.1
git push -u origin master --tags
&lt;/code&gt;&lt;/pre&gt;</description>
          </item>
        
      
    
      
    
      
        
          <item>
            <title>持续集成交付部署</title>
            <link>https://yumminhuang.github.io/post/ci/</link>
            <pubDate>Sat, 05 Mar 2016 17:29:12 -0500</pubDate>
            
            <guid>https://yumminhuang.github.io/post/ci/</guid>
            <description>&lt;p&gt;最近看了一篇文章 &lt;a href=&#34;http://www.mindtheproduct.com/2016/02/what-the-hell-are-ci-cd-and-devops-a-cheatsheet-for-the-rest-of-us/&#34;&gt;&lt;em&gt;The Product Managers’ Guide to Continuous Delivery and DevOps&lt;/em&gt;&lt;/a&gt;。
文中对「持续集成（ &lt;em&gt;Continuous Integration&lt;/em&gt; ）」、「持续交付（ &lt;em&gt;Continuous Delivery&lt;/em&gt; ）」和「持续部署（ &lt;em&gt;Continuous Deployment&lt;/em&gt; ）」这三个概念有很详细的解释。这里借用文中的插图，说一下我对这三个概念的理解。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;持续集成&#34;&gt;持续集成&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn02.mindtheproduct.com/wp-content/uploads/2015/12/409-images-for-snap-blog-postedit_image1.png&#34; alt=&#34;Continuous Integration&#34; style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试、打包等步骤。根据反馈的测试结果，我们可以知道新代码和原有代码能否正确地集成在一起。&lt;/p&gt;

&lt;h3 id=&#34;持续交付&#34;&gt;持续交付&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn02.mindtheproduct.com/wp-content/uploads/2015/12/409-images-for-snap-blog-postedit_image4-manual.png&#34; alt=&#34;Continuous Delivery&#34; style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境（ &lt;em&gt;production-like environments&lt;/em&gt; ）」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中进行更多的测试。如果代码没有问题，接下来就可以继续&lt;strong&gt;手动部署&lt;/strong&gt;到生产环境中。&lt;/p&gt;

&lt;h3 id=&#34;持续部署&#34;&gt;持续部署&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://cdn02.mindtheproduct.com/wp-content/uploads/2015/12/409-images-for-snap-blog-postedit_image3-auto.png&#34; alt=&#34;Continuous Deployment&#34; style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。&lt;/p&gt;

&lt;p&gt;我个人觉得持续集成、持续交付、持续部署非常值得推广。开发过程中最怕集成时遇到问题导致返工，而持续集成、持续交付、持续部署恰恰可以做到问题早发现早解决，从而可以避免这样的麻烦。另外，持续集成、持续交付、持续部署的流程高度依赖自动化工具，所以这种开发方法也可以大大提高开发人员的工作效率。&lt;/p&gt;</description>
          </item>
        
      
    
      
        
          <item>
            <title>Git 工作流</title>
            <link>https://yumminhuang.github.io/post/gitworkingflow/</link>
            <pubDate>Sat, 13 Feb 2016 16:36:21 -0500</pubDate>
            
            <guid>https://yumminhuang.github.io/post/gitworkingflow/</guid>
            <description>&lt;p&gt;Git 可能是每个开发者最常用的工具之一。Git 让开发团队更加方便地进行版本控制和多人协作。但是如果开发团队没有约定如何使用 Git 工作，很可能会导致工作变得一团糟。其中最大的问题是同时存在太多的开发中的分支，每个分支都包含了部分修改。最终开放团队很难弄清楚哪一个分支应该继续开发，或者把它发布成产品。&lt;/p&gt;

&lt;p&gt;正如编程过程中变量命名需要一套标准的命名规则（&lt;a href=&#34;https://en.wikipedia.org/wiki/Naming_convention_(programming)&#34;&gt;Naming convention&lt;/a&gt;）一样，开发团队在使用 Git 的时候，也需要一套标准的工作流，从而确保高效的开发、测试和部署。&lt;/p&gt;

&lt;p&gt;关于 Git 的工作流，业界已经有了很多讨论。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;git-flow&#34;&gt;Git flow&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;git-flow&lt;/a&gt; 最早在2010年提出。用下面这幅图可以概括 git-flow 的主要内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://nvie.com/img/git-model@2x.png&#34; alt=&#34;git-flow&#34; style=&#34;width: 500px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;git-flow 包含一个 &lt;em&gt;master&lt;/em&gt; 分支、一个 &lt;em&gt;develop&lt;/em&gt; 分支，&lt;em&gt;release&lt;/em&gt; 分支、&lt;em&gt;hotfix&lt;/em&gt; 分支和若干 &lt;em&gt;feature&lt;/em&gt; 分支。开发工作在 &lt;code&gt;develop&lt;/code&gt; 进行，然后提交到 &lt;code&gt;release&lt;/code&gt; ，最后合并到 &lt;code&gt;master&lt;/code&gt;。但是 git-flow 太复杂了，需要维护很多分支，开发时还要不停切换分支。所以，到了后来有一些&lt;a href=&#34;http://insights.thoughtworkers.org/gitflow-consider-harmful/&#34;&gt;文章&lt;/a&gt;就对 git-flow 提出了质疑。&lt;/p&gt;

&lt;h3 id=&#34;github-flow&#34;&gt;Github flow&lt;/h3&gt;

&lt;p&gt;Github 针对 git-flow 的不足，并且充分利用 Pull Request 功能，提出了一套更为简单的工作流 —— &lt;a href=&#34;http://scottchacon.com/2011/08/31/github-flow.html&#34;&gt;Github flow&lt;/a&gt;。 Github flow 简化了分支：只有一个可部署的 &lt;code&gt;master&lt;/code&gt; 分支；新添加的代码（不区分 feature、bug-fix）都放在基于 master 创建的新分支里；分支的名称应当能描述出问题（Issue），例如 &lt;code&gt;new-oauth2-scopes&lt;/code&gt;。Github flow 同时还强调持续交付（&lt;a href=&#34;http://martinfowler.com/bliki/ContinuousDelivery.html&#34;&gt;Continuous delivery&lt;/a&gt;）和使用当时 Github 新推出的 Pull Request 进行代码审查（&lt;a href=&#34;https://en.wikipedia.org/wiki/Code_review&#34;&gt;Code review&lt;/a&gt;）。经过几年的发展，Github flow 基本上已经成为业内的标准：几乎所有的代码托管网站、使用 Git 的 SaaS、Git 软件都有基于 branch 的 Pull Request 功能。&lt;/p&gt;

&lt;h3 id=&#34;gitlab-flow&#34;&gt;Gitlab flow&lt;/h3&gt;

&lt;p&gt;但是 Github flow 仍有不足和值得改进的地方，所以 Gitlab 提出了 &lt;a href=&#34;https://about.gitlab.com/2014/09/29/gitlab-flow/&#34;&gt;Gitlab flow&lt;/a&gt;。Github flow 强调持续交付，合并到 &lt;code&gt;master&lt;/code&gt; 的代码要立刻部署到线上。Gitlab 指出这种模式并非适用于所有的开放环境。比如有的软件可能隔几个月，甚至几年才会发布新版本。因此（如下图所示），在这些例子里，创建一个 &lt;em&gt;production&lt;/em&gt; 或 &lt;em&gt;release&lt;/em&gt; 分支来管理发布的代码是有必要的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://about.gitlab.com/images/git_flow/production_branch.png&#34; alt=&#34;gitlab-flow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另外，Gitlab flow 还强调代码的任何修改都应该开始于一个目标明确的Issue。因此，为一个 Issue 创建新分支时，这个分支的名字应该以 Issue 的编号开始，比如 &lt;code&gt;15-require-a-password-to-change-it&lt;/code&gt;。Commit 的信息或 Merge Request 的描述里应关联相关的 Issue，如&lt;code&gt;fixes #14&lt;/code&gt; 或 &lt;code&gt;closes #67&lt;/code&gt;，这样合并到 &lt;code&gt;master&lt;/code&gt; 的时候可以自动关闭相应的 Issue。&lt;/p&gt;

&lt;h3 id=&#34;git-工作流的需求&#34;&gt;Git 工作流的需求&lt;/h3&gt;

&lt;p&gt;在实际开发的过程中，有各种各样的需要。鉴于诸如 &lt;a href=&#34;https://en.wikipedia.org/wiki/Scrum_(software_development)&#34;&gt;Scrum&lt;/a&gt; 之类的敏捷开发方法已经被业界采用，再结合我以前的经验，我觉得 Git 工作流应当结合以下功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;缺陷追踪（&lt;a href=&#34;https://en.wikipedia.org/wiki/Issue_tracking_system&#34;&gt;Issue tracking&lt;/a&gt;）；&lt;/li&gt;
&lt;li&gt;代码审查；&lt;/li&gt;
&lt;li&gt;持续集成（&lt;a href=&#34;http://martinfowler.com/articles/continuousIntegration.html&#34;&gt;Continuous integration&lt;/a&gt;）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，缺陷追踪是非常有必要的。Issue 列表不仅可以帮助整个团队及时了解当前存在的问题和未来需要增加的功能，也可以用来帮助在每个 sprint 前制定 &lt;a href=&#34;https://en.wikipedia.org/wiki/Scrum_(software_development)#Product_backlog&#34;&gt;product backlog&lt;/a&gt;。而且现在市面上大部分的缺陷追踪系统，比如 &lt;a href=&#34;https://www.atlassian.com/software/jira&#34;&gt;JIRA&lt;/a&gt;、&lt;a href=&#34;https://guides.github.com/features/issues/&#34;&gt;Github Issue&lt;/a&gt;， 都整合了 Git，可以通过 Issue 编号相互链接。&lt;/p&gt;

&lt;p&gt;代码审查的重要性不必赘述，在开发过程中，团队成员之间互相检查对于保证代码质量是非常关键的。&lt;/p&gt;

&lt;p&gt;持续集成同样有助于提高代码质量。快速持续的合并到 &lt;code&gt;master&lt;/code&gt; 可以确保团队在最新、最准确的代码上工作，避免了不必要的冲突。通过使用诸如 &lt;a href=&#34;https://yumminhuang.github.io/post/Jenkins/&#34;&gt;Jenkins&lt;/a&gt;、&lt;a href=&#34;https://yumminhuang.github.io/post/TravisCI/&#34;&gt;Travis CI&lt;/a&gt; 之类的持续集成工具，可以自动测试每一个 Pull Request，从而保证 &lt;code&gt;master&lt;/code&gt; 当中代码的正确性。&lt;/p&gt;

&lt;p&gt;另外，Git 工作流还需要满足的要求：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码隔离；&lt;/li&gt;
&lt;li&gt;便于版本回溯；&lt;/li&gt;
&lt;li&gt;可以在尽可能多的平台上使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用 Git 分支最主要的目的就是实现代码隔离，即：每个人能够各自独立工作，互不干扰；未完成和出错的代码不会混在准备发布的代码里。&lt;/p&gt;

&lt;p&gt;使用 Git 还应该能够快速地版本回溯。一旦当前发布的代码出现问题，要能够立刻回溯到上一个可发布版本。&lt;/p&gt;

&lt;p&gt;最后，应该能在尽可能多的平台上，无论是 Github、BitBucket 这样的 SaaS，还是自己使用 Gitlab 搭建的服务器，实践这个工作流。最好可以让 GUI 和 CLI 都能够完成整个工作流。&lt;/p&gt;

&lt;h3 id=&#34;改进的-git-工作流&#34;&gt;改进的 Git 工作流&lt;/h3&gt;

&lt;p&gt;基于 Github flow，并加入 Gitlab flow 的一些优点，我设计了一个改进的 Git 工作流：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt; 时刻保持「可交付」的状态；&lt;/li&gt;
&lt;li&gt;根据 Issue 列表，基于 &lt;code&gt;master&lt;/code&gt; 创建新分支，并采用描述性的命名方法；&lt;/li&gt;
&lt;li&gt;定期 push commits 到服务器；&lt;/li&gt;
&lt;li&gt;在需要反馈、帮助，或解决了一个 issue 时，创建 Pull Request，同时添加 Reviewer；&lt;/li&gt;
&lt;li&gt;使用持续集成技术运行自动化测试，保证测试通过，并进行代码审查；&lt;/li&gt;
&lt;li&gt;合并 Pull Request 到 &lt;code&gt;master&lt;/code&gt; 分支；&lt;/li&gt;
&lt;li&gt;为发布的版本添加 tag。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;master&lt;/code&gt; 时刻保持「可交付」的状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这条应该作为工作流中最基本的准则严格执行。作为 Git 里默认的分支，我们应当保证 &lt;code&gt;master&lt;/code&gt; 里的代码随时可以发布。这样，一旦代码出现了问题，我们可以回到 &lt;code&gt;master&lt;/code&gt; 中之前的版本。&lt;/p&gt;

&lt;p&gt;软件测试的一个基本原则就是无法保证代码中没有 bug。所以，我们只能确保代码满足需求说明文档，是可以发布、部署的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据 Issue 列表，基于 &lt;code&gt;master&lt;/code&gt; 创建新分支，并采用描述性的命名方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如前一条准则所述，&lt;code&gt;master&lt;/code&gt; 里的代码可以认为是正确的，我们可以基于 &lt;code&gt;master&lt;/code&gt; 放心地创建新分支。&lt;/p&gt;

&lt;p&gt;虽然没有必要单独创建 &lt;code&gt;hotfix&lt;/code&gt; 之类的分支，我认为还是有必要在命名时，通过添加前缀 &lt;code&gt;feature/&lt;/code&gt;、&lt;code&gt;fix/&lt;/code&gt;、&lt;code&gt;hotfix/&lt;/code&gt;，对每条分支的内容加以区分。比如，增加一个新特性时，可以给分支命名为 &lt;code&gt;feature/oauth2-login&lt;/code&gt;，修复一个 bug 时，可以给分支命名为&lt;code&gt;fix/memory-leak&lt;/code&gt;。这样既简化了分支管理，避免一个分支存在太长时间，也方便快速了解一个分支的作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定期 push commits 到服务器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定期 push commits 一来可以把代码备份到服务器，也可以让整个团队了解项目的进展。Push 的频率取决于具体的情况。开发一个新功能可能需要花费很长的时间，可以相应地降低 push 的频率；而修复一个 bug，则可能较为紧急，应尽可能快地 push 到服务器上。&lt;/p&gt;

&lt;p&gt;另外，明确的 Commit message 有助于团队协作、回忆开发过程。关于如何写 Commit message，可以参考这篇 &lt;a href=&#34;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&#34;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在需要反馈、帮助，或解决了一个 issue 时，创建 Pull Request，同时添加 Reviewer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在几乎所有的代码托管平台都支持 Pull Request 功能，使用 Pull Request 可以方便地进行团队内的代码审查。有的工具，比如 Bitbucket，可以直接添加 Reviewer。其它工具，比如 Github，也可以通过 &lt;a href=&#34;https://github.com/blog/1121-introducing-team-mentions&#34;&gt;@ 功能&lt;/a&gt;来提醒团队成员进行审查。&lt;/p&gt;

&lt;p&gt;并非在完成全部更改时才可以创建 Pull Request，在遇到问题需要团队帮助或反馈时，同样可以创建 Pull Request，并在 Pull Request 的描述里简述当前的进度。通过和 Reviewer 讨论可以更快地解决问题。这样做也方便让团队其他成员了解项目的进展。&lt;/p&gt;

&lt;p&gt;在 Pull Request 的描述里，可以链接对应的 Issue，方便索引。Github 等也可以在分支被合并的时候&lt;a href=&#34;https://github.com/blog/1506-closing-issues-via-pull-requests&#34;&gt;自动关闭对应的 Issue&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用持续集成技术运行自动化测试，保证测试通过，并进行代码审查&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自动化测试在此不再赘述。我们应当保证所有测试用例都被通过，并且得到所有 Reviewer 的许可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;合并 Pull Request 到 &lt;code&gt;master&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在测试通过，并且所有 Reviewer 都同意之后，就可以把分支里的代码合并到 &lt;code&gt;matser&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;大部分工具都可以在 Pull Request 的图形化页面里直接合并。如果使用命令行，应当使用 &lt;code&gt;git merge --no-ff feature/xxx&lt;/code&gt; 来进行合并。如下图所示，使用 &lt;code&gt;--no-ff&lt;/code&gt; 参数后，会执行正常合并，并在 &lt;code&gt;master&lt;/code&gt; 上生成一个新节点，而非「快进式合并（fast-forward merge）」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201207/bg2012070506.png&#34; alt=&#34;--no-ff merge&#34; style=&#34;height: 300px;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;这样做可以保证版本演进的清晰。&lt;/p&gt;

&lt;p&gt;合并到 &lt;code&gt;master&lt;/code&gt; 之后，创建的分支应当删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为发布的版本添加 tag&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要发布或者部署时，从 &lt;code&gt;master&lt;/code&gt; 里选择最新的版本。可以给该版本添加 tag，比如 &lt;code&gt;v1.0beta&lt;/code&gt;、&lt;code&gt;2.3.2&lt;/code&gt; 等。&lt;/p&gt;

&lt;p&gt;有时候针对不同的演示环境（Staging），可能有必要维护单独的 &lt;em&gt;production&lt;/em&gt; 分支，可以从 &lt;code&gt;master&lt;/code&gt; &lt;a href=&#34;https://git-scm.com/docs/git-cherry-pick&#34;&gt;cherry-pick&lt;/a&gt; 指定的版本到 &lt;code&gt;production&lt;/code&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这是一个基于 Github flow 和 Gitlab flow 的，又根据我自己的经验改进的 Git 工作流，可能还有一些值得改进的地方。也许未来随着开发经验的增加，我会尝试完善这整个流程。&lt;/p&gt;</description>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>如何选择开源项目的证书</title>
            <link>https://yumminhuang.github.io/post/chooseaopensourcelicense/</link>
            <pubDate>Fri, 18 Dec 2015 10:27:50 -0500</pubDate>
            
            <guid>https://yumminhuang.github.io/post/chooseaopensourcelicense/</guid>
            <description>&lt;p&gt;世界上的开源许可证有很多。除了常见的 &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache&lt;/a&gt;，&lt;a href=&#34;http://en.wikipedia.org/wiki/BSD_licenses&#34;&gt;BSD&lt;/a&gt;， &lt;a href=&#34;https://en.wikipedia.org/wiki/MIT_License&#34;&gt;MIT&lt;/a&gt; 等之外，还有一些奇特的证书，比如 &lt;a href=&#34;http://www.wtfpl.net/&#34;&gt;WTFPL (Do What the Fuck You Want to Public License)&lt;/a&gt;。Github 还专门做了一个&lt;a href=&#34;http://choosealicense.com/&#34;&gt;网站&lt;/a&gt; 介绍了常见的开源证书。&lt;/p&gt;

&lt;p&gt;然而开源证书虽多，却很少有人会仔细研究证书上的法律条文，搞清楚它们的区别。我最近看了 Github 的网站，又看了一些网上的文章，稍稍研究了几个常用证书的区别，以及如何为开源项目选择证书。故撰此文以供参考。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;如果开源的内容不是代码，可以选择&lt;a href=&#34;http://creativecommons.org/&#34;&gt;知识共享许可协议&lt;/a&gt;。针对是否需要署名使用，是否可以商用等问题，知识共享许可协议有许多不同的版本，可以访问&lt;a href=&#34;http://creativecommons.org/choose/&#34;&gt;链接&lt;/a&gt;来选择一个合适的知识共享许可协议。&lt;/p&gt;

&lt;p&gt;关于开源的代码，可以依次回答以下的问题来确定开源证书。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是否允许他人闭源使用你的代码？

&lt;ul&gt;
&lt;li&gt;是：继续回答问题2&lt;/li&gt;
&lt;li&gt;否：&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;GPL&lt;/a&gt; (The GNU General Public License)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果他人修改了你的代码，是否需要了解修改？

&lt;ul&gt;
&lt;li&gt;是：&lt;a href=&#34;https://www.eclipse.org/legal/epl-v10.html&#34;&gt;EPL&lt;/a&gt; (Eclipse Public License)&lt;/li&gt;
&lt;li&gt;否：继续回答问题3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;是否打算为代码注册专利？

&lt;ul&gt;
&lt;li&gt;是：Apache License&lt;/li&gt;
&lt;li&gt;否：继续回答问题4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;他人发布时是否需要显式地附带你的证书？

&lt;ul&gt;
&lt;li&gt;是：BSD License&lt;/li&gt;
&lt;li&gt;否：MIT License&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我没有研究各个开源证书的条文，以上内容也只是我的个人理解，难免有错误之处。所以，为一个正式的项目选择开源证书之前，最好还是仔细确认一遍。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;GPL &lt;a href=&#34;https://opensource.org/licenses/gpl-license&#34;&gt;不同的版本之间也有区别&lt;/a&gt;，其中细微的差别对我来说实在难以理解。总之，GPL 是一个 &lt;a href=&#34;http://www.gnu.org/licenses/copyleft.html&#34;&gt;copyleft&lt;/a&gt; 的协议。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
          </item>
        
      
    
      
    
      
    
  </channel>
</rss>
