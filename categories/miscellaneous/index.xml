<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Miscellaneous on 临水轩志</title>
    <link>https://yumminhuang.github.io/categories/miscellaneous/</link>
    <description>Recent content in Miscellaneous on 临水轩志</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>2018 ~ Yaming Huang</copyright>
    <lastBuildDate>Sun, 31 Dec 2017 17:25:51 +0800</lastBuildDate>
    
	<atom:link href="https://yumminhuang.github.io/categories/miscellaneous/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>程序员使用的笔记软件</title>
      <link>https://yumminhuang.github.io/post/quiver_snippetslab/</link>
      <pubDate>Sun, 31 Dec 2017 17:25:51 +0800</pubDate>
      
      <guid>https://yumminhuang.github.io/post/quiver_snippetslab/</guid>
      <description>&lt;p&gt;我一直在寻找一款工作上适合程序员使用的笔记软件。工作的时候，经常需要记录一些代码片段和笔记。这类笔记大部分都不成体系，记录的都是一些工作上的要点和代码片段。有的时候只是临时保存一小段代码。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>清理 Docker</title>
      <link>https://yumminhuang.github.io/post/dockerclenup/</link>
      <pubDate>Fri, 13 Oct 2017 22:26:29 +0800</pubDate>
      
      <guid>https://yumminhuang.github.io/post/dockerclenup/</guid>
      <description>&lt;p&gt;在线上环境运行的 Docker 的时候，部署之后往往没有清理旧版本的镜像和关闭的容器。如此一来，长时间运行 Docker，尤其是频繁地更新镜像、启动容器，会消耗大量的磁盘空间。&lt;/p&gt;

&lt;p&gt;本文汇总几条用来清理 Docker 的命令。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搭建分布式 Gerrit 集群</title>
      <link>https://yumminhuang.github.io/post/distributedgerrit/</link>
      <pubDate>Sun, 10 Sep 2017 11:31:51 +0800</pubDate>
      
      <guid>https://yumminhuang.github.io/post/distributedgerrit/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.gerritcodereview.com&#34;&gt;Gerrit&lt;/a&gt; 是由 Google为了管理 Android 项目而开发的，一款免费、开源的代码审查软件。Gerrit 使用 Git 作为底层版本控制系统，提供了代码审查、权限管理等功能。&lt;/p&gt;

&lt;p&gt;本文将会简单介绍如何搭建分布式 Gerrit 集群，即搭建由一个可以读写的 Gerrit Master 和若干个只读的 Gerrit Slave 组成的 Gerrit 集群。Gerrit Slave 可以实时同步 Gerrit Master 的数据，保证代码的一致性。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>自动构建 Github Pages 博客</title>
      <link>https://yumminhuang.github.io/post/autobuildblog/</link>
      <pubDate>Sat, 12 Nov 2016 12:31:51 +0800</pubDate>
      
      <guid>https://yumminhuang.github.io/post/autobuildblog/</guid>
      <description>&lt;p&gt;之前曾经写过了一篇 &lt;a href=&#34;https://yumminhuang.github.io/post/AutoBuildResume/&#34;&gt;使用 Travis CI 和 Docker 自动构建 LaTeX 简历&lt;/a&gt;，介绍了使用 Travis CI 和 Docker 自动构建和发布 LaTeX 简历的方法。&lt;/p&gt;

&lt;p&gt;以前每次写了新文章之后，都需要在笔记本上运行一下 Hugo 再将生成的网页上传到 Github。虽然使用脚本也可以做到一键发布，但总觉得不够流畅。昨天，我又使用了同样的方法，将基于 Github Pages 的博客也实现了自动构建和发布。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Travis CI 和 Docker 自动构建 LaTeX 简历</title>
      <link>https://yumminhuang.github.io/post/autobuildresume/</link>
      <pubDate>Fri, 08 Apr 2016 15:17:48 -0400</pubDate>
      
      <guid>https://yumminhuang.github.io/post/autobuildresume/</guid>
      <description>&lt;p&gt;又快到了求职季，最近一段时间总是频繁更新的简历。之前，我的简历更新流程是先修改简历，使用 MacTeX 编译，再把 PDF 版的简历同步到几个网盘备份。过程倒也不算繁琐。但再做过几个月的运维开放之后，我对自动化有着近乎偏执的热情。这几天经过不断的尝试和摸索，在 Travis-CI 上运行了十几个 Build 之后，终于使用 Docker 实现了一个便捷的自动化发布 LaTeX 简历的方法。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Two Coding Problems</title>
      <link>https://yumminhuang.github.io/note/codingproblems/</link>
      <pubDate>Fri, 18 Dec 2015 16:53:33 -0500</pubDate>
      
      <guid>https://yumminhuang.github.io/note/codingproblems/</guid>
      <description>Two coding problems I encountered in a recent interview.
Problem 1  Problem: Print a binary tree row-by-row, from top to bottom.
Example:
 Input: Binary tree 3 / \ 1 4 \ \ 2 5 Output: 3, 1, 4, 2, 5 Solution
class Node(object): def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right def traverse(rootnode): # The list to save all visited nodes visited = list() # BFS thislevel = [rootnode] while thislevel: nextlevel = list() for n in thislevel: visited.</description>
    </item>
    
    <item>
      <title>如何选择开源项目的证书</title>
      <link>https://yumminhuang.github.io/post/chooseaopensourcelicense/</link>
      <pubDate>Fri, 18 Dec 2015 10:27:50 -0500</pubDate>
      
      <guid>https://yumminhuang.github.io/post/chooseaopensourcelicense/</guid>
      <description>&lt;p&gt;世界上的开源许可证有很多。除了常见的 &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache&lt;/a&gt;，&lt;a href=&#34;http://en.wikipedia.org/wiki/BSD_licenses&#34;&gt;BSD&lt;/a&gt;， &lt;a href=&#34;https://en.wikipedia.org/wiki/MIT_License&#34;&gt;MIT&lt;/a&gt; 等之外，还有一些奇特的证书，比如 &lt;a href=&#34;http://www.wtfpl.net/&#34;&gt;WTFPL (Do What the Fuck You Want to Public License)&lt;/a&gt;。Github 还专门做了一个&lt;a href=&#34;http://choosealicense.com/&#34;&gt;网站&lt;/a&gt; 介绍了常见的开源证书。&lt;/p&gt;

&lt;p&gt;然而开源证书虽多，却很少有人会仔细研究证书上的法律条文，搞清楚它们的区别。我最近看了 Github 的网站，又看了一些网上的文章，稍稍研究了几个常用证书的区别，以及如何为开源项目选择证书。故撰此文以供参考。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Site Reliability Engineer Interview</title>
      <link>https://yumminhuang.github.io/note/sreinterview/</link>
      <pubDate>Thu, 03 Dec 2015 23:35:42 -0500</pubDate>
      
      <guid>https://yumminhuang.github.io/note/sreinterview/</guid>
      <description>&lt;p&gt;Recently, I had a phone interview for a position of Site Reliability Engineer. They asked me four questions in 60 minutes. I was asked to writing code on &lt;a href=&#34;http://collabedit.com/&#34;&gt;collabedit&lt;/a&gt;
Because Site Reliability Team of that company uses Python and I also prefer to Python, so all solutions are written in Python.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Calculating Quantiles</title>
      <link>https://yumminhuang.github.io/note/calculatingquantiles/</link>
      <pubDate>Thu, 03 Dec 2015 21:12:18 -0500</pubDate>
      
      <guid>https://yumminhuang.github.io/note/calculatingquantiles/</guid>
      <description>&lt;p&gt;This problem is from my recent online coding test. I didn&amp;rsquo;t solve it in the limited time cause I used a wrong way. When I realize that, I don&amp;rsquo;t have enough time to fix it. I feel regretful for failing the test.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>将博客由 Pelican 迁移到 Hugo</title>
      <link>https://yumminhuang.github.io/post/migratetohugo/</link>
      <pubDate>Fri, 13 Nov 2015 09:38:53 -0500</pubDate>
      
      <guid>https://yumminhuang.github.io/post/migratetohugo/</guid>
      <description>&lt;p&gt;前两天花了一些时间研究了一下 &lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;Hugo 的文档&lt;/a&gt;，并且把博客从 &lt;a href=&#34;http://blog.getpelican.com/&#34;&gt;Pelican&lt;/a&gt; 迁移到 Hugo。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>One Trick for Debugging Python</title>
      <link>https://yumminhuang.github.io/note/pythondebugtrick/</link>
      <pubDate>Mon, 11 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://yumminhuang.github.io/note/pythondebugtrick/</guid>
      <description>I just learned one trick for debugging Python script from my colleague. It&amp;rsquo;s not such magical maybe most of Pythonistee have already used it everyday), but I think it is very useful to debug Python script.
I only need to add single line at the position I want to break.
import code; code.interact(local=locals()) After that, run Python script as usual. Python Interpreter will stop at your break point and launch a REPL (Read–eval–print loop) console.</description>
    </item>
    
    <item>
      <title>Yelp Interview Problem</title>
      <link>https://yumminhuang.github.io/note/yelpinterviewproblem/</link>
      <pubDate>Tue, 18 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yumminhuang.github.io/note/yelpinterviewproblem/</guid>
      <description>&lt;p&gt;Today, I had a skype interview with Yelp.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Objective-C 语法总结</title>
      <link>https://yumminhuang.github.io/post/objective-creference/</link>
      <pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://yumminhuang.github.io/post/objective-creference/</guid>
      <description>&lt;p&gt;最近在学习 Objective-C。产生学习 Objective-C 的想法已经很久了，但是以前每次看到 Objective-C 代码就会觉得语法非常奇怪，于是学习的动力就受到的打击。恰逢放假，可以平心静气地学习 Objective-C。&lt;/p&gt;

&lt;p&gt;在看过了 Objective-C 的基本语法之后，明白了为什么之前会觉得 Objective-C 的语法奇怪。绝大部分的面向对象的程序语言，包括 C++、Java、Python 等在调用方法的格式都是 &lt;code&gt;object.method(argument1, argument2...)&lt;/code&gt;。然而 Objective-C 的格式却是 &lt;code&gt;[object method: argument1 andArg: argument2...]&lt;/code&gt;。所以长期使用 C++, Java 的程序员在第一次看到 Objective-C 代码时，对这些语法肯定有一些不适应。但是适应这些语法并仔细研究之后感觉 Objective-C 的语法也有它的优点。
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>