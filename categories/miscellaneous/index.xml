<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Miscellaneous on 临水轩志</title>
    <link>http://yumminhuang.github.io/categories/miscellaneous/</link>
    <description>Recent content in Miscellaneous on 临水轩志</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 18 Dec 2015 16:53:33 -0500</lastBuildDate>
    <atom:link href="http://yumminhuang.github.io/categories/miscellaneous/index.xml" rel="self" type="application/rss+xml" />
    
      
    
      
        
          <item>
            <title>如何选择开源项目的证书</title>
            <link>http://yumminhuang.github.io/blog/2015/12/18/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%81%E4%B9%A6/</link>
            <pubDate>Fri, 18 Dec 2015 10:27:50 -0500</pubDate>
            
            <guid>http://yumminhuang.github.io/blog/2015/12/18/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AF%81%E4%B9%A6/</guid>
            <description>&lt;p&gt;世界上的开源许可证有很多。除了常见的 &lt;a href=&#34;http://www.apache.org/licenses/LICENSE-2.0&#34;&gt;Apache&lt;/a&gt;，&lt;a href=&#34;http://en.wikipedia.org/wiki/BSD_licenses&#34;&gt;BSD&lt;/a&gt;， &lt;a href=&#34;https://en.wikipedia.org/wiki/MIT_License&#34;&gt;MIT&lt;/a&gt; 等之外，还有一些奇特的证书，比如 &lt;a href=&#34;http://www.wtfpl.net/&#34;&gt;WTFPL (Do What the Fuck You Want to Public License)&lt;/a&gt;。Github 还专门做了一个&lt;a href=&#34;http://choosealicense.com/&#34;&gt;网站&lt;/a&gt; 介绍了常见的开源证书。&lt;/p&gt;

&lt;p&gt;然而开源证书虽多，却很少有人会仔细研究证书上的法律条文，搞清楚它们的区别。我最近看了 Github 的网站，又看了一些网上的文章，稍稍研究了几个常用证书的区别，以及如何为开源项目选择证书。故撰此文以供参考。&lt;/p&gt;

&lt;p&gt;如果开源的内容不是代码，可以选择&lt;a href=&#34;http://creativecommons.org/&#34;&gt;知识共享许可协议&lt;/a&gt;。针对是否需要署名使用，是否可以商用等问题，知识共享许可协议有许多不同的版本，可以访问&lt;a href=&#34;http://creativecommons.org/choose/&#34;&gt;链接&lt;/a&gt;来选择一个合适的知识共享许可协议。&lt;/p&gt;

&lt;p&gt;关于开源的代码，可以依次回答以下的问题来确定开源证书。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是否允许他人闭源使用你的代码？

&lt;ul&gt;
&lt;li&gt;是：继续回答问题2&lt;/li&gt;
&lt;li&gt;否：&lt;a href=&#34;http://www.gnu.org/licenses/gpl-3.0.en.html&#34;&gt;GPL&lt;/a&gt; (The GNU General Public License)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:79a41204317e0bfdc567861d342a8b18:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:79a41204317e0bfdc567861d342a8b18:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果他人修改了你的代码，是否需要了解修改？

&lt;ul&gt;
&lt;li&gt;是：&lt;a href=&#34;https://www.eclipse.org/legal/epl-v10.html&#34;&gt;EPL&lt;/a&gt; (Eclipse Public License)&lt;/li&gt;
&lt;li&gt;否：继续回答问题3&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;是否打算为代码注册专利？

&lt;ul&gt;
&lt;li&gt;是：Apache License&lt;/li&gt;
&lt;li&gt;否：继续回答问题4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;他人发布时是否需要显式地附带你的证书？

&lt;ul&gt;
&lt;li&gt;是：BSD License&lt;/li&gt;
&lt;li&gt;否：MIT License&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我没有研究各个开源证书的条文，以上内容也只是我的个人理解，难免有错误之处。所以，为一个正式的项目选择开源证书之前，最好还是仔细确认一遍。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:79a41204317e0bfdc567861d342a8b18:1&#34;&gt;GPL &lt;a href=&#34;https://opensource.org/licenses/gpl-license&#34;&gt;不同的版本之间也有区别&lt;/a&gt;，其中细微的差别对我来说实在难以理解。总之，GPL 是一个 &lt;a href=&#34;http://www.gnu.org/licenses/copyleft.html&#34;&gt;copyleft&lt;/a&gt; 的协议。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:79a41204317e0bfdc567861d342a8b18:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>将博客由 Pelican 迁移到 Hugo</title>
            <link>http://yumminhuang.github.io/blog/2015/11/13/%E5%B0%86%E5%8D%9A%E5%AE%A2%E7%94%B1-pelican-%E8%BF%81%E7%A7%BB%E5%88%B0-hugo/</link>
            <pubDate>Fri, 13 Nov 2015 09:38:53 -0500</pubDate>
            
            <guid>http://yumminhuang.github.io/blog/2015/11/13/%E5%B0%86%E5%8D%9A%E5%AE%A2%E7%94%B1-pelican-%E8%BF%81%E7%A7%BB%E5%88%B0-hugo/</guid>
            <description>&lt;p&gt;前两天花了一些时间研究了一下 &lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;Hugo 的文档&lt;/a&gt;，并且把博客从 &lt;a href=&#34;http://blog.getpelican.com/&#34;&gt;Pelican&lt;/a&gt; 迁移到 Hugo。&lt;/p&gt;

&lt;p&gt;Pelican 是一个优秀的静态博客生成器。当初选用 Pelican 的主要是因为它是用 Python 开发的，而我又对 Python 比较熟悉。而且 Pelican 有很多由第三方开发者制作的插件提供了更多的功能。但是长期使用的过程中还是有一些小小的麻烦。当初，我想给博客里的中文文章添加&lt;a href=&#34;https://css.hanzi.co/&#34;&gt;「汉字标准格式」&lt;/a&gt; 这个框架，需要向模版里添加一段引入 CSS 和 JS 代码。但是 Pelican 的模版不易更改，我需要为了修改一两行 HTML 文件 Fork 之前的模版，方法既不优雅，维护成本又很高。另外，Pelican 的模版似乎是全局性的，所有的页面都使用相同的模版。&lt;/p&gt;

&lt;p&gt;后来，无意之间发现 Hugo 在配置和文件结构上和 Pelican 有很大的不同，大大地提高了可配置性，可以解决上述的两个问题。此外，第一次看到  &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo 官网&lt;/a&gt;的首页的时候，看上去非常漂亮，令人印象深刻。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;hugo new site SITE_DIR&lt;/code&gt; 新建一个 Hugo 之后，生成以下路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── archetypes/
├── config.toml
├── content/
├── data/
├── layouts/
└── static/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt; 用来存放设置。&lt;code&gt;content/&lt;/code&gt; 里存放的是文章，&lt;code&gt;data/&lt;/code&gt; 用来存放一些数据。 &lt;code&gt;static/&lt;/code&gt; 里是需要引入的 CSS 或图片之类的文件。如果需要添加现场的主题模版，可以添加到 &lt;code&gt;themes/&lt;/code&gt; 里并在&lt;code&gt;config.toml&lt;/code&gt; 里设置。这些内容和 Pelican、Jekyll 一样，有的也可以望文生义，猜到大致的作用。&lt;/p&gt;

&lt;p&gt;加下来着重介绍的是 &lt;code&gt;layouts/&lt;/code&gt;，这里定义了博客的模版，是自定义 Hugo 最重要的部分。和 Pelican 有很大不同的地方是，Hugo 可以自定义文章的类型（ Type ）。不同的类型可以使用不同的模版。比如，除了第三方主题提供的文章类型，我还想为中文文章新建一个类型 &lt;code&gt;zhpost&lt;/code&gt;。只需要在 &lt;code&gt;layouts/&lt;/code&gt; 下新建一个 &lt;code&gt;zhpost/&lt;/code&gt;。接着，我可以设置中文文章的样式，只需新建一个 &lt;code&gt;single.html&lt;/code&gt; 就可以了。我也因此可以在&lt;code&gt;layouts/zhpost/single.html&lt;/code&gt; 里引入「汉字标准格式」的 CSS 和 JS。另外，对于第三方主题的模版不满意的话还可以按照相同的路径重写一个。Hugo 会优先读取根目录下 &lt;code&gt;layouts/&lt;/code&gt; 里的设置。具体来说，&lt;code&gt;layouts/post/single.html&lt;/code&gt; 可以覆盖 &lt;code&gt;themes/THEME/layouts/post/single.html&lt;/code&gt;。这样我就可以很容易的替换不满意的模版了。&lt;/p&gt;

&lt;p&gt;Hugo 的可定制性非常高，从 404 页面，到文章列表的页面都可以修改，而且可以做到不同类型的文章使用不一样的样式。具体的配置需要参考&lt;a href=&#34;http://themes.gohugo.io/&#34;&gt;第三方的主题&lt;/a&gt;的设置和 Hugo 的文档。&lt;/p&gt;

&lt;p&gt;值得一提的是，Go 的模版语言可读性很高，几乎不需要花额外的时间学习。我对照着别人开发的主题照葫芦画瓢就完成了模版的定义和修改。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;archetypes/&lt;/code&gt;，用来存放定义的「原型」。原型的作用是自动添加文字的元数据。比如，我想每次创建 &lt;code&gt;post&lt;/code&gt; 类文章的时候都自动添加元数据，只需要在 &lt;code&gt;archetypes/&lt;/code&gt; 里添加一个 &lt;code&gt;post.md&lt;/code&gt;，并加入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;my new post&amp;quot;
date = &amp;quot;2015-01-12T19:20:04-07:00&amp;quot;
tags = [&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;]
categories = [&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;]
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样每次运行 &lt;code&gt;hugo new post/ARTICLE.md&lt;/code&gt; 的时候都可以自动添加上面的元数据。&lt;/p&gt;

&lt;p&gt;Hugo 另外的一个优点是生成博客的速度非常快，生成一个网页的速度可以达到毫秒级别。如果博客的内容很多，Hugo 要比 Pelican、Jekyll 等由动态语言写成的博客生成器有很大的优势。&lt;/p&gt;

&lt;p&gt;当然，Hugo 也有不足。比如，Hugo 默认是不支持代码高亮的，需要额外设置。此外，在 Pelican 里，可以通过 &lt;a href=&#34;https://github.com/yuex/cjk-auto-spacing&#34;&gt;cjk-auto-spacing&lt;/a&gt; 插件来自动在英文单词和汉字之间插入空格，这对于有大量中英文混排的技术笔记来说非常方便。但是，目前我还没有找到 Hugo 有类似的解决方法，暂时只能在写文章的时候手工加入空格。&lt;/p&gt;

&lt;p&gt;刚开始使用 Hugo，有一些诸如 Taxonomies，Section 之类的功能还没有仔细研究。这篇文章也是草草完成，不慎严谨，俟后完善。&lt;/p&gt;
</description>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>Objective-C 语法总结</title>
            <link>http://yumminhuang.github.io/blog/2014/05/04/objective-c-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</link>
            <pubDate>Sun, 04 May 2014 00:00:00 +0000</pubDate>
            
            <guid>http://yumminhuang.github.io/blog/2014/05/04/objective-c-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
            <description>

&lt;p&gt;最近在学习 Objective-C。产生学习 Objective-C 的想法已经很久了，但是以前每次看到 Objective-C 代码就会觉得语法非常奇怪，于是学习的动力就受到的打击。恰逢放假，可以平心静气地学习 Objective-C。&lt;/p&gt;

&lt;p&gt;在看过了 Objective-C 的基本语法之后，明白了为什么之前会觉得 Objective-C 的语法奇怪。绝大部分的面向对象的程序语言，包括 C++、Java、Python 等在调用方法的格式都是 &lt;code&gt;object.method(argument1, argument2...)&lt;/code&gt;。然而 Objective-C 的格式却是 &lt;code&gt;[object method: argument1 andArg: argument2...]&lt;/code&gt;。所以长期使用 C++, Java 的程序员在第一次看到 Objective-C 代码时，对这些语法肯定有一些不适应。但是适应这些语法并仔细研究之后感觉 Objective-C 的语法也有它的优点。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;废话不多说，上干货。下面以 Java 作比对，总结一下 Objective-C 的语法。&lt;/p&gt;

&lt;h3 id=&#34;1-基本语法:f380f29864ae1f196ebf2be42cd77c15&#34;&gt;1. 基本语法&lt;/h3&gt;

&lt;h4 id=&#34;1-1-创建对象:f380f29864ae1f196ebf2be42cd77c15&#34;&gt;1.1 创建对象&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj = new MyClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Objective-C:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass *obj = [[MyClass alloc] init];
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-调用方法:f380f29864ae1f196ebf2be42cd77c15&#34;&gt;1.2 调用方法&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method1() // 没有参数
obj.method2(arg1) // 一个参数
obj.method3(arg1,arg2) // 多个参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Objective-C:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[obj method1] // 没有参数
[obj method2:arg1] // 一个参数
[obj method3:arg2 andArg: arg2] // 多个参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-类的定义:f380f29864ae1f196ebf2be42cd77c15&#34;&gt;2. 类的定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyClass extend SuperClass {

    private int attr1;

    public void method1() {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Objective-C:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Objectove-C 定义一个类时需要两个文件，分别是负责声明的 Header File 和负责具体实现的 Implementation File。&lt;/p&gt;

&lt;p&gt;MyClass.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface MyClass : SuperClass
{
    int attr1;
}
- (void) method1;
- (void) method2: int arg1;
- (void) method3: int arg1 andArg: (NSString *) arg2;
+ (void) classMethod; // 相当于 Java 中的 static 方法
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyClass.m&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import&amp;quot;MyClass.h&amp;quot;
@implementation MyClass
- (void) method1
{
    ...
}
...
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，Objective-C 还有一个非常方便的 “语法糖”——&lt;code&gt;@property&lt;/code&gt; 和 &lt;code&gt;@synthesize&lt;/code&gt; 两个关键字。使用这两个关键字之后可以让编译好器自动编写一个与数据成员同名的方法声明从而省去读写方法的声明。
在头文件中加上 &lt;code&gt;@property int attr1;&lt;/code&gt; 就等同于声明了两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	- (int)attr1;
	- (void)setAttr1:(int)newAttr1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现文件里加上 &lt;code&gt;@synthesize attr1;&lt;/code&gt; 就等同于定义了两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (int)attr1
{
	return attr1;
}
-(void)setAttr1:(int)newAttr1
{
   	attr1 = newAttr1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-协议-接口-的定义:f380f29864ae1f196ebf2be42cd77c15&#34;&gt;3. 协议（接口）的定义&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Java:&lt;/strong&gt;
定义接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface MyInterface {
	public void aInterfaceMethod();
	public void anotherInterfaceMethod();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyClass extend SuperClass implements MyInterface {
	// method declarations
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Objective-C:&lt;/strong&gt;
在 Objective-C 中，用关键字 &lt;code&gt;@protocol&lt;/code&gt; 定义协议，也就是 Java 中的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@protocol MyProtocol
- (void) aProtocolMethod;
- (void) anotherProcotolMethod;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当一个类需要实现协议时，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;quot;MyProtocol.h&amp;quot;
@interface MyClass : SuperClass &amp;lt;MyProtocol, AnotherProtocol&amp;gt;
	// method declarations
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;由于我也是初学 Objective-C，难免有错误和总结不全面的地方，恳请指正。&lt;/p&gt;
</description>
          </item>
        
      
    
  </channel>
</rss>
